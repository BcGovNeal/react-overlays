{"version":3,"sources":["webpack:///./src/pages/use-popper.js","webpack:///./src/components/HookDocumentation.js"],"names":["UsePopperPage","location","usePopperDocs","data","className","id","dangerouslySetInnerHTML","__html","description","childMarkdownRemark","html","docs","pageQuery","Wrapper","styled","displayName","styles","require","attrs","vars","TypeComponent","children","Punctuation","Operator","TypeExpression","arrayOfElements","joiner","type","name","elements","map","element","index","key","reduce","acc","current","push","React","cloneElement","expression","applications","FunctionSignature","definition","block","ignoreParams","params","filter","param","includes","Fragment","optional","returns","length","isFunctionDef","recursive","typeDef","SignatureElement","fallbackToName","renderParam","titleElement","childrenDocumentationJs","HookDocumentation"],"mappings":"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","file":"component---src-pages-use-popper-js-7cb42e19758cdff5a43f.js","sourcesContent":["import { graphql } from 'gatsby';\nimport React from 'react';\nimport Anchor from '../components/Anchor';\nimport HookDocumentation from '../components/HookDocumentation';\nimport Page from '../components/Page';\n\nconst propTypes = {};\n\nfunction UsePopperPage({ location, data: { usePopperDocs } }) {\n  return (\n    <Page location={location}>\n      <h2 className=\"page-header\">\n        <Anchor id=\"use-popper\">usePopper</Anchor>\n      </h2>\n      <p\n        dangerouslySetInnerHTML={{\n          __html: usePopperDocs.description.childMarkdownRemark.html,\n        }}\n      />\n\n      <HookDocumentation docs={usePopperDocs} />\n    </Page>\n  );\n}\n\nUsePopperPage.propTypes = propTypes;\n\nexport default UsePopperPage;\n\nexport const pageQuery = graphql`\n  query usePopperQuery {\n    usePopperDocs: documentationJs(name: { eq: \"usePopper\" }) {\n      ...HookDocumentation_docs\n    }\n  }\n`;\n","import styled from 'astroturf';\nimport { graphql } from 'gatsby';\nimport React from 'react';\n\nconst Wrapper = /*#__PURE__*/styled('span', null, {\n  displayName: \"Wrapper\",\n  styles: require(\"./HookDocumentation-Wrapper.module.scss\"),\n  attrs: null,\n  vars: []\n});\n\nconst TypeComponent = ({ children }) => (\n  <span className=\"token builtin\">{children}</span>\n);\n\nconst Punctuation = ({ children }) => (\n  <span className=\"token punctuation\">{children}</span>\n);\n\nconst Operator = ({ children }) => (\n  <span className=\"token operator\">{children}</span>\n);\n\nconst join = (arrayOfElements, joiner) =>\n  arrayOfElements.reduce((acc, current, index) => {\n    if (index > 0) {\n      acc.push(\n        React.cloneElement(joiner, {\n          key: `joiner ${index}`,\n        }),\n      );\n    }\n    acc.push(current);\n\n    return acc;\n  }, []);\n\nconst TypeExpression = ({ type }) => {\n  if (type.type === `NameExpression`) {\n    return <TypeComponent>{type.name}</TypeComponent>;\n  }\n  if (type.type === `NullLiteral`) {\n    return <TypeComponent>null</TypeComponent>;\n  }\n  if (type.type === `UndefinedLiteral`) {\n    return <TypeComponent>undefined</TypeComponent>;\n  }\n  if (type.type === `UnionType`) {\n    return (\n      <>\n        {join(\n          type.elements.map((element, index) => (\n            <TypeExpression key={`union element ${index}`} type={element} />\n          )),\n          <Operator> | </Operator>,\n        )}\n      </>\n    );\n  }\n  if (type.type === `TypeApplication` && type.expression) {\n    if (type.expression.name === `Array`) {\n      return (\n        <>\n          <TypeExpression type={type.applications[0]} />\n          <Operator>[]</Operator>\n        </>\n      );\n    }\n    return (\n      <>\n        <TypeExpression type={type.expression} />\n        {`<`}\n        <TypeExpression type={type.applications[0]} />\n        {`>`}\n      </>\n    );\n  }\n  return null;\n};\n\nconst FunctionSignature = ({ definition, block, ignoreParams }) => {\n  const params = definition.params\n    ? definition.params\n        .filter(param => !ignoreParams.includes(param.name))\n        .map((param, index) => (\n          <React.Fragment key={param.name}>\n            {index > 0 && <Punctuation>, </Punctuation>}\n            {param.name}\n            {param.type && (\n              <>\n                <Punctuation>{param.optional && '?'}:</Punctuation>{' '}\n                <TypeExpression type={param.type} />\n              </>\n            )}\n          </React.Fragment>\n        ))\n    : null;\n\n  return (\n    <Wrapper block={block}>\n      <Punctuation>(</Punctuation>\n      {params}\n      <Punctuation>)</Punctuation> <Operator>=&gt;</Operator>{' '}\n      {definition.returns && definition.returns.length ? (\n        <TypeExpression type={definition.returns[0].type} />\n      ) : (\n        <TypeComponent>undefined</TypeComponent>\n      )}\n    </Wrapper>\n  );\n};\n\nconst isFunctionDef = (definition, recursive = true) =>\n  (definition.params && definition.params.length > 0) ||\n  (definition.returns && definition.returns.length > 0) ||\n  (recursive &&\n    definition.type &&\n    definition.type.typeDef &&\n    isFunctionDef(definition.type.typeDef, false));\n\nconst SignatureElement = ({\n  definition,\n  fallbackToName = false,\n  block = false,\n}) => {\n  if (isFunctionDef(definition, false)) {\n    return <FunctionSignature definition={definition} block={block} />;\n  }\n\n  if (definition.type && definition.type.typeDef) {\n    return (\n      <SignatureElement\n        definition={definition.type.typeDef}\n        fallbackToName\n        block={block}\n      />\n    );\n  }\n\n  if (definition.type) {\n    return (\n      <Wrapper block={block}>\n        <TypeExpression type={definition.type} />\n      </Wrapper>\n    );\n  }\n\n  if (fallbackToName && definition.name) {\n    return (\n      <Wrapper block={block}>\n        <TypeComponent>{definition.name}</TypeComponent>\n      </Wrapper>\n    );\n  }\n\n  return null;\n};\n\nfunction renderParam(definition) {\n  let titleElement = definition.name;\n\n  if (titleElement) {\n    titleElement = <code>{titleElement}</code>;\n  }\n\n  return (\n    <li key={definition.name}>\n      <div className=\"prism-code\">\n        {titleElement}{' '}\n        <SignatureElement\n          definition={definition}\n          block={isFunctionDef(definition)}\n        />\n      </div>\n      {!!definition.childrenDocumentationJs.length && (\n        <ul>{definition.childrenDocumentationJs.map(renderParam)}</ul>\n      )}\n    </li>\n  );\n}\n\nfunction HookDocumentation({ docs }) {\n  const { params } = docs;\n  return (\n    <section className=\"mb-4\">\n      <h3 className=\"h4\">Parameters</h3>\n      <ul>{params.map(renderParam)}</ul>\n    </section>\n  );\n}\n\nexport default HookDocumentation;\n\nexport const fragment = graphql`\n  fragment description on DocumentationJSComponentDescription {\n    childMarkdownRemark {\n      html\n    }\n  }\n\n  fragment paramsBase on DocumentationJs {\n    id\n    name\n    type {\n      type\n      name\n      elements\n      params\n      applications\n    }\n    description {\n      ...description\n    }\n  }\n\n  fragment params on DocumentationJs {\n    ...paramsBase\n    childrenDocumentationJs {\n      ...paramsBase\n      childrenDocumentationJs {\n        ...paramsBase\n      }\n    }\n  }\n\n  fragment HookDocumentation_docs on DocumentationJs {\n    id\n    name\n    kind\n    description {\n      ...description\n    }\n    params {\n      ...params\n    }\n    returns {\n      ...params\n    }\n  }\n`;\n"],"sourceRoot":""}